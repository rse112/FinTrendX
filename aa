import trend
import select_keyword
import utils
from datetime import datetime
import pandas as pd
from pytz import timezone
from dateutil.relativedelta import relativedelta
import asyncio

from trend import trend_maincode 

class analysis:
    def __init__(self):
        self.formatted_today, self.day=utils.get_today_date()
        self.state=utils.load_state()
        self.apiCallCount = self.state.get('api_request_count', 1)
        self.current_client_index = self.state.get('current_client_index', 0)
        self.keywords = utils.load_keywords('main_keyword.json')['keyword_final']
        self.request_limit = 1000
        self.keyword_index = self.state['keyword_index']
        self.standard_time = datetime.now()
        self.api_url = "https://openapi.naver.com/v1/datalab/search"
        self.today = datetime.now(timezone('Asia/Seoul'))
        self.api_request_data = pd.DataFrame(columns=['search_keywords'])
        self.start_index = (self.today - relativedelta(days=1)).strftime("%Y-%m-%d")
        self.end_index = (self.today - relativedelta(years=3) - relativedelta(days=1)).strftime("%Y-%m-%d")
        
        ############
        # api 아이디 비번
        ############
        self.clients = utils.get_secret("clients")



        # 데이터프레임 초기화
        self.trends_dataframes = {
        'daily_up': pd.DataFrame(),
        'weekly_up': pd.DataFrame(),
        'weekly_stay': pd.DataFrame(),
        'monthly_up': pd.DataFrame(),
        'monthly_stay': pd.DataFrame(),
        'monthly_rule': pd.DataFrame()
        }


        self.graph_tables = {
        'day': pd.DataFrame(index=pd.date_range(start=self.start_index, end=self.end_index, freq='1d')),
        'week': pd.DataFrame(index=pd.date_range(start=self.start_index, end=self.end_index, freq='7d')),
        'month': pd.DataFrame(index=pd.date_range(start=self.start_index, end=self.end_index, freq='28d'))
        }

        # 정보 저장을 위한 딕셔너리 초기화
        self.keyword_data = {
            'keyword_categories': {},
            'related_search_terms': {},
            'related_search_volume': {},
            'up_month': {}
        }
        self.review_types = {
                'daily': {
                        'function': select_keyword.select_keyword,
                        'info_dict': {},
                        'trend_df': self.trends_dataframes['daily_up'],
                        'graph_df': self.graph_tables['day'],
                        'time_period': 'daily'
                    },
            'weekly_up': {
                        'function': select_keyword.select_keyword,
                        'info_dict': {},
                        'trend_df': self.trends_dataframes['weekly_up'],
                        'graph_df': self.graph_tables['week'],
                        'time_period': 'weekly'
                    },
            'weekly_stay': {
                        'function': select_keyword.rising_keyword_analysis,
                        'info_dict': {},
                        'trend_df': self.trends_dataframes['weekly_stay'],
                        'graph_df': self.graph_tables['month'],
                        'time_period': 'weekly'
                    },
            'monthly_up': {
                        'function': select_keyword.select_keyword,
                        'info_dict': {},
                        'trend_df': self.trends_dataframes['monthly_up'],
                        'graph_df': self.graph_tables['month'],
                        'time_period': 'month'
                    },
            'monthly_stay': {
                        'function': select_keyword.rising_keyword_analysis,
                        'info_dict': {},
                        'trend_df': self.trends_dataframes['monthly_stay'],
                        'graph_df': self.graph_tables['month'],
                        'time_period': 'month'
                    },
            'monthly_rule': {
                        'function': select_keyword.monthly_rule,
                        'info_dict': {},
                        'trend_df': self.trends_dataframes['monthly_rule'],
                        'graph_df': self.graph_tables['month'],
                        'time_period': 'month'
                    }
                }
        pass

    def handle_api_call(self,keywordName,df_table,currentRequestCount):
        if self.apiCallCount<= self.request_limit:
            id_num,pw,_=utils.get_client_info(self.clients,self.current_client_index)
            id = self.clients[id_num]['client_id']
            pw=self.clients[id_num]['client_secret']
            utils.log_progress(keywordName, currentRequestCount, \
                               len(df_table), id, self.apiCallCount, self.request_limit)
            related_keyword = df_table['연관키워드'][currentRequestCount]
            request_data = {
            
            'search_keywords': related_keyword,

            }        
            return request_data, self.apiCallCount + 1, self.current_client_index
        else:
                # 요청 한도 초과 시 클라이언트 인덱스 업데이트
                self.current_client_index += 1
                if self.current_client_index >= len(self.clients):
                    print("모든 API 클라이언트의 요청 한도 초과")
                    return None, self.apiCallCount, self.current_client_index  # 처리 중단을 위한 None 반환
                else:
                    # 클라이언트 전환 후 재시도
                    return self.handle_api_call(keywordName, currentRequestCount, df_table)
                
                
    def update_client_credentials(self):
        # 클라이언트 인덱스 업데이트
        self.current_client_index += 1
        if self.current_client_index >= len(self.clients):
            print("모든 API 클라이언트의 요청 한도 초과")
            return False  # 모든 클라이언트의 한도가 초과되었음을 나타내는 신호로 False 반환
        else:
            # 새 클라이언트 정보로 업데이트
            self.apiCallCount = 1  # API 호출 카운트 초기화
            return True

    def analyze_trend_data(self, keywordName):
        unique_api_request_data = self.api_request_data.drop_duplicates(subset=['search_keywords'])
            # 딕셔너리 데이터로 변환

        unique_api_request_data_dict = unique_api_request_data.to_dict(orient='list')
        params = {
            "search_keywords": unique_api_request_data_dict["search_keywords"],  # search_keywords 값을 search_words 키로 사용합니다.
            "id": self.clients['id_1']["client_id"],
            "pw": self.clients['id_1']["client_secret"],
            "api_url": self.api_url
        }
        trend_data = asyncio.run(trend_maincode(params,self.clients, self.api_url))

    #시작 인덱스 찾기
    def collect_and_analyze_keyword_trends(self):
        
        total_keywords=len(self.keywords)
        for keywordName   in self.keywords[self.keyword_index:]:
            df_table = pd.read_csv('./data/rl_srch/' + str(self.day) + f'/{keywordName}.csv', encoding='euc-kr')
            print(f'################################################ {keywordName } ({self.keyword_index+1}/{total_keywords}) ################################################')
            maxKeyword = min(50, len(df_table))
            for currentRequestCount  in range(self.state['currentRequestCount_index'], maxKeyword):
                request_data, self.apiCallCount, self.current_client_index = self.handle_api_call(keywordName,df_table,currentRequestCount)

                #api 요청 예외처리(한도초과시 클라이언트 인덱스 업데이트)
                if request_data is not None:
                    new_row=pd.DataFrame([request_data])
                    self.api_request_data=pd.concat([self.api_request_data,new_row])
                else:
                    break
            
                
            if self.current_client_index >= len(self.clients):
                print("모든 API 클라이언트의 요청 한도 초과")
                break
            self.keyword_index+=1
            print(f'API 요청 데이터 수: {len(self.api_request_data)}')
            # self.trends_dataframes, self.graph_tables, self.keyword_data =self.analyze_trend_data(self.api_request_data)


            self.analyze_trend_data(keywordName)
    
import time
if __name__ == "__main__":
    start=time.time()
    analysis_instance = analysis()
    analysis_instance.collect_and_analyze_keyword_trends()
    print(time.time()-start)